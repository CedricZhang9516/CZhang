#include "GaudiKernel/MsgStream.h"
#include "GaudiKernel/AlgFactory.h"
#include "GaudiKernel/ISvcLocator.h"
#include "GaudiKernel/SmartDataPtr.h"
#include "GaudiKernel/IDataProviderSvc.h"
#include "GaudiKernel/PropertyMgr.h"
#include "VertexFit/IVertexDbSvc.h"
#include "GaudiKernel/Bootstrap.h"
#include "GaudiKernel/ISvcLocator.h"
#include "GaudiKernel/NTuple.h"
#include "GaudiKernel/IHistogramSvc.h"


#include "EventModel/EventModel.h"
#include "EventModel/Event.h"
#include "McTruth/McParticle.h"
#include "EvtRecEvent/EvtRecEvent.h"
#include "EvtRecEvent/EvtRecTrack.h"
#include "DstEvent/TofHitStatus.h"
#include "EventModel/EventHeader.h"

#include "GaudiKernel/INTupleSvc.h"
#include "GaudiKernel/NTuple.h"
#include "GaudiKernel/Bootstrap.h"
#include "CLHEP/Vector/ThreeVector.h"
#include "CLHEP/Vector/LorentzVector.h"
#include "CLHEP/Vector/TwoVector.h"

#include "CLHEP/Vector/ThreeVector.h"
#include "CLHEP/Vector/LorentzVector.h"
#include "CLHEP/Vector/TwoVector.h"
using CLHEP::Hep3Vector;
using CLHEP::Hep2Vector;
using CLHEP::HepLorentzVector;
#include "CLHEP/Geometry/Point3D.h"
#ifndef ENABLE_BACKWARDS_COMPATIBILITY
typedef HepGeom::Point3D<double> HepPoint3D;
#endif

#include "RhopiAlg/Rhopi.h"
//#include "VertexFit/IVertexDbsvc.h"
#include "VertexFit/KinematicFit.h"
#include "VertexFit/KalmanKinematicFit.h"
#include "VertexFit/VertexFit.h"
#include "VertexFit/Helix.h"
#include "ParticleID/ParticleID.h"

#include "TMath.h"
#include <vector>
#include <iostream>
#include <fstream>

//const double twopi = 6.2831853;
//const double pi = 3.1415927;
const double mpi = 0.13957;
const double mmu = 0.105658;
const double xmass[5] = {0.000511, 0.105658, 0.139570,0.493677, 0.938272};

//const double velc = 29.9792458;  tof_path unit in cm.
const double velc = 299.792458;   // tof path unit in mm

typedef std::vector<int> Vint;
typedef std::vector<HepLorentzVector> Vp4;

//int Ncut0,Ncut1,Ncut2,Ncut3,Ncut4,Ncut5,Ncut6,Ncut7,Ncut8,Ncut9,Ng1,Ng2,Ng3;
int Ncut0 = 0;		//total event
int Ncut1 = 0;		//Pass good charged tracks cut
int Ncut2 = 0;		//Pass good photon
int Ncut3 = 0;		//Pass E/p
int Ncut4 = 0;		//Pass MUC
int Ncut5 = 0;		//Pass 4C
int Ncut6 = 0;		//Pass 5C

int Ng1 = 0;
int Ng2 = 0;
int NgAbove2 = 0;

/////////////////////////////////////////////////////////////////////////////

Rhopi::Rhopi(const std::string& name, ISvcLocator* pSvcLocator) :
	Algorithm(name, pSvcLocator) {

		//Declare the properties
		declareProperty("OutputFileName",  m_OutputFileName = "out.root");
		declareProperty("Ecms",  m_Ecms = 3.097);
		//declareProperty("EnergySpread",  m_EnergySpread = 0.0011);
		declareProperty("saveTopo", m_saveTopo = 0);//need to be re-evaluated when running different samples(1 for MC)
		declareProperty("saveMCTruth", m_saveMCTruth = 0);//need to be re-evaluated when running different samples(only 1 for exclusiveMC)

		//For charged track
		//
		//origin
		//declareProperty("Vr0cut", m_vr0cut=1.0);
		//declareProperty("Vz0cut", m_vz0cut=10.0);
		
		//changed
		declareProperty("Vr0cut", m_vr0cut=2.0);
		declareProperty("Vz0cut", m_vz0cut=20.0);

		//for good photon selection
		declareProperty("EnergyThreshold", m_energyThreshold=0.04);
		declareProperty("GammaPhiCut", m_gammaPhiCut=20.0);
		declareProperty("GammaThetaCut", m_gammaThetaCut=20.0);
		declareProperty("GammaAngleCut", m_gammaAngleCut=20.0);
		declareProperty("BarrelEnergyThreshold", m_barrelEnergyThreshold=0.025);
		declareProperty("EndEnergyThreshold",m_endEnergyThreshold=0.050);


		//for test4c and pid
		declareProperty("Test4C", m_test4C = 0);
		declareProperty("Test5C", m_test5C = 0);
		declareProperty("CheckDedx", m_checkDedx = 0);
		declareProperty("CheckTof",  m_checkTof = 0);
		//////////////////////////////////////////////////////////////////////////////
		////////my private value
		/////////////////////////////////////////////////////////////////////////////
		declareProperty("Ene_lowThreshold",m_ene_lowThreshold = 0.15);
		declareProperty("Ene_highThreshold",m_ene_highThreshold = 0.24);
		declareProperty("Ep_ratioThreshold",m_ep_ratioThreshold = 0.3);
		declareProperty("CheckRatio",m_checkRatio = 0);
		declareProperty("PtThreshold",m_pt_Threshold= 0.3); 
		declareProperty("CheckMuc",m_checkMuc = 0);


		declareProperty("WritePredata",m_writePredata=0);
		///////////////////////////  end     ///////////////////////////////////////

	}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
StatusCode Rhopi::initialize(){
	MsgStream log(msgSvc(), name());
	std::cout<<"lify's initialize has started!"<<std::endl;
	log << MSG::INFO << "in initialize()" << endmsg;
	StatusCode status;

	//Output name
	TString s_OutputFileName(m_OutputFileName);

	//Tree and File Modified
	saveFile = new TFile(s_OutputFileName, "recreate");
	TreeAna = new TTree("save", "save");

	//Overall info
	TreeAna->Branch("runid", &runid, "runid/I");
	TreeAna->Branch("evtid", &evtid, "evtid/I");

	//No. of each events
	TreeAna->Branch("nevt", &nevt, "nevt/I");
	TreeAna->Branch("nNEUTRAL", &nNEUTRAL, "nNEUTRAL/I");
	TreeAna->Branch("nCHARGED",&nCHARGED,"nCHARGED/I");
	TreeAna->Branch("nTRACKS",&nTRACKS,"nTRACKS/I");
	TreeAna->Branch("nGamma", &nGamma, "nGamma/I");

	//parimary vertex and track info
	TreeAna->Branch("vx0", &m_vx0, "vx0/D");
	TreeAna->Branch("vy0", &m_vy0, "vy0/D");
	TreeAna->Branch("vz0", &m_vz0, "vz0/D");
	TreeAna->Branch("vr0", &m_vr0, "vr0/D");
	TreeAna->Branch("rvxy0", &m_rvxy0, "rvxy0/D");
	TreeAna->Branch("rvz0", &m_rvz0, "rvz0/D");
	TreeAna->Branch("rvphi0", &m_rvphi0, "rvphi0/D");
	TreeAna->Branch("rtheta0", &m_rtheta0, "rtheta0/D");

	//momentum and energy
	//positive
	TreeAna->Branch("ppos", &m_ppos_ratio, "ppos/D");
	TreeAna->Branch("epos", &m_epos_ratio, "epos/D");
	TreeAna->Branch("depos", &m_depos_ratio, "depos/D");
	TreeAna->Branch("EPRatioPlus", &m_eppos_ratio, "EPRatioPlus/D");
	//negative
	TreeAna->Branch("pneg", &m_pneg_ratio, "pneg/D");
	TreeAna->Branch("eneg", &m_eneg_ratio, "eneg/D");
	TreeAna->Branch("deneg", &m_deneg_ratio, "deneg/D");
	TreeAna->Branch("EPRatioMinu", &m_epneg_ratio, "EPRatioMinu/D");
	//total mass of two tracks
	TreeAna->Branch("TMass", &m_tmass_ratio, "TMass/D");

	//for 4C
	TreeAna->Branch("chi1", &m_chi1, "chi1/D");
	TreeAna->Branch("mmu0", &m_mmu0, "mmu0/D");

	//for 5c
	TreeAna->Branch("chi2", &m_chi2, "chi2/D");
	TreeAna->Branch("mmu1", &m_mmu1, "mmu1/D");
	/* 
	   TreeAna->Branch("costheta_chrgd", costheta_chrgd, "costheta_chrgd[6]/D");
	   TreeAna->Branch("Rxy", Rxy, "Rxy[6]/D");
	   TreeAna->Branch("Rz", Rz, "Rz[6]/D");
	   TreeAna->Branch("Rvxy", Rvxy, "Rvxy[6]/D");
	   TreeAna->Branch("Rvz", Rvz, "Rvz[6]/D");

	   TreeAna->Branch("vxchisq", &vxchisq, "vxchisq/D");
	   TreeAna->Branch("kmchisq_pi0", kmchisq_pi0, "kmchisq_pi0[nevt]/D");
	   TreeAna->Branch("kmchisq_4c", kmchisq_4c, "kmchisq_4c[nevt]/D");

	   TreeAna->Branch("id_gamma1", id_gamma1, "id_gamma1[nevt]/I");
	   TreeAna->Branch("id_gamma2", id_gamma2, "id_gamma2[nevt]/I");
	   */


	//---------------------------------------------------------------------------
	/*
	   NTuplePtr nt1(ntupleSvc(), "FILE1/vxyz");
	   if ( nt1 ) m_tuple1 = nt1;
	   else {
	   m_tuple1 = ntupleSvc()->book ("FILE1/vxyz", CLID_ColumnWiseTuple, "ks N-Tuple example");
	   if ( m_tuple1 )    {
	   status = m_tuple1->addItem ("vx0",   m_vx0);
	   status = m_tuple1->addItem ("vy0",   m_vy0);
	   status = m_tuple1->addItem ("vz0",   m_vz0);
	   status = m_tuple1->addItem ("vr0",   m_vr0);
	   status = m_tuple1->addItem ("rvxy0",  m_rvxy0);
	   status = m_tuple1->addItem ("rvz0",   m_rvz0);
	   status = m_tuple1->addItem ("rvphi0", m_rvphi0);
	   }
	   else    { 
	   log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple1) << endmsg;
	   return StatusCode::FAILURE;
	   }
	   }

	//---------------------------------------------------------------------------
	NTuplePtr nt2(ntupleSvc(), "FILE1/photon");
	if ( nt2 ) m_tuple2 = nt2;
	else {
	m_tuple2 = ntupleSvc()->book ("FILE1/photon", CLID_ColumnWiseTuple, "ks N-Tuple example");
	if ( m_tuple2 )    {
	status = m_tuple2->addItem ("dthe",   m_dthe);
	status = m_tuple2->addItem ("dphi",   m_dphi);
	status = m_tuple2->addItem ("dang",   m_dang);
	status = m_tuple2->addItem ("eraw",   m_eraw);
	}
	else    { 
	log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple2) << endmsg;
	return StatusCode::FAILURE;
	}
	}


	// test 4C
	NTuplePtr nt4(ntupleSvc(), "FILE1/4C");
	if ( nt4 ) m_tuple4 = nt4;
	else {
	m_tuple4 = ntupleSvc()->book ("FILE1/4C", CLID_ColumnWiseTuple, "ks N-Tuple example");
	if ( m_tuple4 )    {
	status = m_tuple4->addItem ("mmu0",   m_mmu0);
	status = m_tuple4->addItem ("chi1",   m_chi1);
	}
	else    { 
	log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple4) << endmsg;
	return StatusCode::FAILURE;
	}
	}  

	// test 5C
	NTuplePtr nt5(ntupleSvc(), "FILE1/5C");
	if ( nt5 ) m_tuple5 = nt5;
	else {
	m_tuple5 = ntupleSvc()->book ("FILE1/5C", CLID_ColumnWiseTuple, "ks N-Tuple example");
	if ( m_tuple5 )    {
	status = m_tuple5->addItem ("mmu1",   m_mmu1);
	status = m_tuple5->addItem ("chi2",   m_chi2);
	}
	else    { 
	log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple5) << endmsg;
	return StatusCode::FAILURE;
	}
	}  


	//de/dx
	if(m_checkDedx == 1) {
	NTuplePtr nt7(ntupleSvc(), "FILE1/dedx");
	if ( nt7 ) m_tuple7 = nt7;
	else {
		m_tuple7 = ntupleSvc()->book ("FILE1/dedx", CLID_ColumnWiseTuple, "ks N-Tuple example");
		if ( m_tuple7 )    {
			status = m_tuple7->addItem ("ptrk",   m_ptrk);
			status = m_tuple7->addItem ("chie",   m_chie);
			status = m_tuple7->addItem ("chimu",   m_chimu);
			status = m_tuple7->addItem ("chipi",   m_chipi);
			status = m_tuple7->addItem ("chik",   m_chik);
			status = m_tuple7->addItem ("chip",   m_chip);
			status = m_tuple7->addItem ("probPH",   m_probPH);
			status = m_tuple7->addItem ("normPH",   m_normPH);
			status = m_tuple7->addItem ("ghit",   m_ghit);
			status = m_tuple7->addItem ("thit",   m_thit);
		}
		else    { 
			log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple7) << endmsg;
			return StatusCode::FAILURE;
		}
	}
} // check dE/dx

// check Tof:endcap



// check Tof:barrel inner Tof 




NTuplePtr nt11(ntupleSvc(), "FILE1/pid");
if ( nt11 ) m_tuple11 = nt11;
else {
	m_tuple11 = ntupleSvc()->book ("FILE1/pid", CLID_ColumnWiseTuple, "ks N-Tuple example");
	if ( m_tuple11 )    {
		status = m_tuple11->addItem ("ptrk",   m_ptrk_pid);
		status = m_tuple11->addItem ("cost",   m_cost_pid);
		status = m_tuple11->addItem ("dedx",   m_dedx_pid);
		status = m_tuple11->addItem ("tof1",   m_tof1_pid);
		status = m_tuple11->addItem ("tof2",   m_tof2_pid);
		status = m_tuple11->addItem ("prob",   m_prob_pid);
	}
	else    { 
		log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple11) << endmsg;
		return StatusCode::FAILURE;
	}
}

//Initialize my data value for E/p
NTuplePtr nt12(ntupleSvc(), "FILE1/ep_ratio");
if ( nt12 ) m_tuple12 = nt12;
else {
	m_tuple12 = ntupleSvc()->book ("FILE1/ep_ratio", CLID_ColumnWiseTuple, "ks N-Tuple example");
	if ( m_tuple12 )    {
		status = m_tuple12->addItem ("epos_ratio",   m_epos_ratio);
		status = m_tuple12->addItem ("eneg_ratio",   m_eneg_ratio);
		status = m_tuple12->addItem ("ppos_ratio",   m_ppos_ratio);  
		status = m_tuple12->addItem ("pneg_ratio",   m_pneg_ratio);
		status = m_tuple12->addItem ("depos_ratio",   m_depos_ratio);
		status = m_tuple12->addItem ("deneg_ratio",   m_deneg_ratio);
		status = m_tuple12->addItem ("eppos_ratio",   m_eppos_ratio);
		status = m_tuple12->addItem ("epneg_ratio",   m_epneg_ratio);
		status = m_tuple12->addItem ("tmass_ratio",   m_tmass_ratio);
	}
	else    { 
		log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple12) << endmsg;
		return StatusCode::FAILURE;
	}
}

//initialize for data for mass to add
NTuplePtr nt13(ntupleSvc(), "FILE1/inv_ene");
if ( nt13 ) m_tuple13 = nt13;
else {
	m_tuple13 = ntupleSvc()->book ("FILE1/inv_ene", CLID_ColumnWiseTuple, "ks N-Tuple example");
	if ( m_tuple13 )    {
		status = m_tuple13->addItem ("ene1",   m_ene1);
		status = m_tuple13->addItem ("ene2",   m_ene2);}
	else    { 
		log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple13) << endmsg;
		return StatusCode::FAILURE;
	}
}
//
NTuplePtr nt14(ntupleSvc(), "FILE1/pre_ene");
if ( nt14 ) m_tuple14 = nt14;
else {
	m_tuple14 = ntupleSvc()->book ("FILE1/pre_ene", CLID_ColumnWiseTuple, "ks N-Tuple example");
	if ( m_tuple14 )    {
		status = m_tuple14->addItem ("prep1",   m_prep1);
		status = m_tuple14->addItem ("prep2",   m_prep2);
		status = m_tuple14->addItem ("epremass",   m_epremass);
		status = m_tuple14->addItem ("mupremass",   m_mupremass);}
	else    { 
		log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple14) << endmsg;
		return StatusCode::FAILURE;
	}
}

NTuplePtr nt15(ntupleSvc(), "FILE1/muc_cut");
if ( nt15 ) m_tuple15 = nt15;
else {
	m_tuple15 = ntupleSvc()->book ("FILE1/muc_cut", CLID_ColumnWiseTuple, "ks N-Tuple example");
	if ( m_tuple15 )    {
		status = m_tuple15->addItem ("posdepthMuc",   m_posdepthMuc);
		status = m_tuple15->addItem ("poslayerMuc",   m_poslayerMuc);
		status = m_tuple15->addItem ("negdepthMuc",   m_negdepthMuc);
		status = m_tuple15->addItem ("neglayerMuc",   m_neglayerMuc);}
	else    { 
		log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple15) << endmsg;
		return StatusCode::FAILURE;
	}
}

/////////////////////////////////////below is MC topoloy book////////////////////////////

NTuplePtr nt0(ntupleSvc(), "FILE1/MCtopo");
if ( nt0 ) m_tuple0 = nt0;
else {
	m_tuple0 = ntupleSvc()->book ("FILE1/MCtopo", CLID_ColumnWiseTuple, "ks N-Tuple example");
	if ( m_tuple0 )    {
		status = m_tuple0->addItem ("run",  m_run );
		status = m_tuple0->addItem ("rec",  m_rec );
		status = m_tuple0->addItem("indexmc",          m_idxmc, 0, 100);
		status = m_tuple1->addIndexedItem("trkidx",    m_idxmc, m_trkidx);
		status = m_tuple0->addIndexedItem("pdgid",     m_idxmc, m_pdgid);
		status = m_tuple0->addIndexedItem("motheridx", m_idxmc, m_motheridx);}
	else    { 
		log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple0) << endmsg;
		return StatusCode::FAILURE;
	}
}
////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////final momentum and energy/////////////////////

NTuplePtr nt16(ntupleSvc(), "FILE1/result");
if ( nt16 ) m_tuple16 = nt16;
else {
	m_tuple16 = ntupleSvc()->book ("FILE1/result", CLID_ColumnWiseTuple, "ks N-Tuple example");
	if ( m_tuple16 )    {
		status = m_tuple16->addItem ("eposmu",   m_eposmu);
		status = m_tuple16->addItem ("enegmu",   m_enegmu);
		status = m_tuple16->addItem ("pposmu",   m_pposmu);  
		status = m_tuple16->addItem ("pnegmu",   m_pnegmu);
		status = m_tuple16->addItem ("tmassmumu",   m_tmassmumu);
	}
	else    { 
		log << MSG::ERROR << "    Cannot book N-tuple:" << long(m_tuple16) << endmsg;
		return StatusCode::FAILURE;
	}
}

////////////////////////////////////////////////////////////////////////////////////////
*/

//--------end of book--------
//

log << MSG::INFO << "successfully return from initialize()" <<endmsg;
std::cout<<"success initialize completed!"<<std::endl;
return StatusCode::SUCCESS;
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
StatusCode Rhopi::execute() {

	std::cout << "execute()" << std::endl;

	MsgStream log(msgSvc(), name());
	log << MSG::INFO << "in execute()" << endreq;

	SmartDataPtr<Event::EventHeader> eventHeader(eventSvc(),"/Event/EventHeader");
	int runNo=eventHeader->runNumber();
	int event=eventHeader->eventNumber();

	//--------------------------------below is topology----------------------------------------------
	/*
	   int saveMC=1;

	   if (saveMC==1){
	   m_run = eventHeader->runNumber();
	   m_rec = eventHeader->eventNumber();
	   if (eventHeader->runNumber()<0)
	   {

	   SmartDataPtr<Event::McParticleCol> mcParticleCol(eventSvc(), "/Event/MC/McParticleCol");

	   int m_numParticle = 0;
	   if (!mcParticleCol)
	   {
	   std::cout << "Could not retrieve McParticelCol" << std::endl;
	   return StatusCode::FAILURE;
	   }
	   else
	   {
	   bool psipDecay = false;
	   int rootIndex = -1;
	   Event::McParticleCol::iterator iter_mc = mcParticleCol->begin();
	   for (; iter_mc != mcParticleCol->end(); iter_mc++)
	   {
	   if ((*iter_mc)->primaryParticle()) continue;
	   if (!(*iter_mc)->decayFromGenerator()) continue;
	//if ( ((*iter_mc)->mother()).trackIndex()<3 ) continue;
	if ((*iter_mc)->particleProperty()==100443) 
	{
	psipDecay = true;
	rootIndex = (*iter_mc)->trackIndex();
	}
	if (!psipDecay) continue;
	int trkidx = (*iter_mc)->trackIndex() - rootIndex;
	int mcidx = ((*iter_mc)->mother()).trackIndex() - rootIndex;
	int pdgid = (*iter_mc)->particleProperty();
	m_trkidx[m_numParticle] = trkidx;
	m_pdgid[m_numParticle] = pdgid;
	m_motheridx[m_numParticle] = mcidx;
	m_numParticle += 1;    
	}
	}
	m_idxmc = m_numParticle;
	m_tuple0->write();
	}
	}
	*/
	//---------------------------------------------end---------------------------------------------------



	log << MSG::DEBUG <<"run, evtnum = "
		<< runNo << " , "
		<< event <<endreq;
	cout<<"event "<<event<<endl;
	Ncut0++;

	if(!(Ncut0%10000))
	{
		cout<<"Processing "<<Ncut0<<"th event:   "<<" Run Id = "<<runNo<<", Event Id = "<<event<<endl;
		cout<<"Total =  "<<Ncut0<<", after good charged tracks cut = "<<Ncut1<<endl;
	}

	SmartDataPtr<EvtRecEvent> evtRecEvent(eventSvc(), EventModel::EvtRec::EvtRecEvent);
	SmartDataPtr<EvtRecTrackCol> evtRecTrkCol(eventSvc(),  EventModel::EvtRec::EvtRecTrackCol);
	
	nCHARGED = evtRecEvent->totalCharged();
	nNEUTRAL = evtRecEvent->totalNeutral();
	nTRACKS = evtRecEvent->totalTracks();

	//  log << MSG::INFO << "get event tag OK" << endreq;
	log << MSG::DEBUG <<"ncharg, nneu, tottks = " 
		<< nCHARGED << " , "
		<< nNEUTRAL << " , "
		<< nTRACKS <<endreq;

	//
	// check x0, y0, z0, r0
	// suggest cut: |z0|<5 && r0<1
	//
	Vint iGood, ipip, ipim;
	iGood.clear();
	ipip.clear();
	ipim.clear();
	Vp4 ppip, ppim;
	ppip.clear();
	ppim.clear();

	int nGood = 0;
	int nCharge = 0;

	HepLorentzVector p4_cms(0.011*m_Ecms,0.,0.,m_Ecms);
	Hep3Vector xorigin(0,0,0);

	//if (m_reader.isRunNumberValid(runNo)) {
	IVertexDbSvc*  vtxsvc;
	Gaudi::svcLocator()->service("VertexDbSvc", vtxsvc);

	if(vtxsvc->isVertexValid()){
		double* dbv = vtxsvc->PrimaryVertex(); 
		double*  vv = vtxsvc->SigmaPrimaryVertex();  
		//    HepVector dbv = m_reader.PrimaryVertex(runNo);
		//    HepVector vv = m_reader.SigmaPrimaryVertex(runNo);
		xorigin.setX(dbv[0]);
		xorigin.setY(dbv[1]);
		xorigin.setZ(dbv[2]);
	}

	for(int i = 0; i < evtRecEvent->totalCharged(); i++){
		EvtRecTrackIterator itTrk=evtRecTrkCol->begin() + i;
		if(!(*itTrk)->isMdcTrackValid()) continue;
		RecMdcTrack *mdcTrk = (*itTrk)->mdcTrack();
		double pch=mdcTrk->p();
		double x0=mdcTrk->x();
		double y0=mdcTrk->y();
		double z0=mdcTrk->z();
		double phi0=mdcTrk->helix(1);
		double xv=xorigin.x();
		double yv=xorigin.y();
		double Rxy=(x0-xv)*cos(phi0)+(y0-yv)*sin(phi0);
		m_vx0 = x0;
		m_vy0 = y0;
		m_vz0 = z0;
		m_vr0 = Rxy;

		HepVector a = mdcTrk->helix();
		HepSymMatrix Ea = mdcTrk->err();
		HepPoint3D point0(0.,0.,0.);   // the initial point for MDC recosntruction
		HepPoint3D IP(xorigin[0],xorigin[1],xorigin[2]); 
		VFHelix helixip(point0,a,Ea); 
		helixip.pivot(IP);
		HepVector vecipa = helixip.a();
		double  Rvxy0=fabs(vecipa[0]);  //the nearest distance to IP in xy plane
		double  Rvz0=vecipa[3];         //the nearest distance to IP in z direction
		double  Rvphi0=vecipa[1];
		m_rvxy0=Rvxy0;
		m_rvz0=Rvz0;
		m_rvphi0=Rvphi0;
		m_rtheta0=mdcTrk->theta();

		//m_tuple1->write();
		//    if(fabs(z0) >= m_vz0cut) continue;
		//    if(fabs(Rxy) >= m_vr0cut) continue;

		//  if(fabs(Rvz0) >= 10.0) continue;
		//  if(fabs(Rvxy0) >= 1.0) continue;
		//	if(fabs(cos(mdcTrk->theta())) > 0.93) continue;	
		//    cut for track     

		if(fabs(Rvz0) >= m_vz0cut) continue;
		if(fabs(Rvxy0) >= m_vr0cut) continue;
		if(fabs(cos(mdcTrk->theta())) > 0.93) continue;	
		//
		iGood.push_back(i);
		nCharge += mdcTrk->charge();
	}

	//
	// Finish Good Charged Track Selection
	//
	nGood = iGood.size();
	log << MSG::DEBUG << "ngood, totcharge = " << nGood << " , " << nCharge << endreq;
	if((nGood != 2)||(nCharge!=0)){
		return StatusCode::SUCCESS;
	}
	Ncut1++;

	Vint iGam;
	iGam.clear();
	for(int i = evtRecEvent->totalCharged(); i< evtRecEvent->totalTracks(); i++) {
		EvtRecTrackIterator itTrk=evtRecTrkCol->begin() + i;
		if(!(*itTrk)->isEmcShowerValid()) continue;
		RecEmcShower *emcTrk = (*itTrk)->emcShower();


		//backup
		//double time=emcTrk->time();
		//double the=emcTrk->energy();
		//double eraw=emcTrk->theta();
		
		double time=emcTrk->time();
		double the=emcTrk->theta();
		double eraw=emcTrk->energy();

		if(time < 0||time >14) continue;							//time cut
		Hep3Vector emcpos(emcTrk->x(), emcTrk->y(), emcTrk->z());

		double e_threshold=10.0;

		if(fabs(cos(the))<0.82)
		{
			e_threshold = m_barrelEnergyThreshold;
		}
		else if((fabs(cos(the))>0.85) && (fabs(cos(the)) < 0.92))
		{
			e_threshold = m_endEnergyThreshold;
		}
		else 
		{
			continue;
		}

		if(eraw < e_threshold) continue;



		// find the nearest charged track
		double dthe = 200.;
		double dphi = 200.;
		double dang = 200.; 

		for(int j = 0; j < evtRecEvent->totalCharged(); j++) {
			EvtRecTrackIterator jtTrk = evtRecTrkCol->begin() + j;

			if(!(*jtTrk)->isExtTrackValid()) continue;
			RecExtTrack *extTrk = (*jtTrk)->extTrack();

			if(extTrk->emcVolumeNumber() == -1) continue;
			Hep3Vector extpos = extTrk->emcPosition();

			//      double ctht = extpos.cosTheta(emcpos);
			double angd = extpos.angle(emcpos);
			double thed = extpos.theta() - emcpos.theta();
			double phid = extpos.deltaPhi(emcpos);


			thed = fmod(thed+CLHEP::twopi+CLHEP::twopi+pi, CLHEP::twopi) - CLHEP::pi;
			phid = fmod(phid+CLHEP::twopi+CLHEP::twopi+pi, CLHEP::twopi) - CLHEP::pi;

			if(angd < dang){
				dang = angd;
				dthe = thed;
				dphi = phid;

			}
		}
		if(dang>=200) continue;
		//double eraw = emcTrk->energy();
		dthe = dthe * 180 / (CLHEP::pi);
		dphi = dphi * 180 / (CLHEP::pi);
		dang = dang * 180 / (CLHEP::pi);

	//		m_dthe = dthe;
	//	m_dphi = dphi;
	//	m_dang = dang;
	//	m_eraw = eraw;
	//	m_tuple2->write();

		//	if(eraw < m_energyThreshold) continue;
		if((fabs(dthe) < m_gammaThetaCut) && (fabs(dphi)<m_gammaPhiCut) ) continue;
		if(fabs(dang) < m_gammaAngleCut) continue;
		//
		// good photon cut will be set here
		//
		iGam.push_back(i);
	}

	//
	// Finish Good Photon Selection
	//
	int nGam = iGam.size();
	nGamma=nGam;

	log << MSG::DEBUG << "num Good Photon " << nGam  << " , " <<evtRecEvent->totalNeutral()<<endreq;
	// if(nGam<2){
	//    return StatusCode::SUCCESS;
	//  }
	int showGam=1;

	if(showGam==1)  

	{
		if(nGam==1)
		{
			Ng1++;
		}
		if(nGam==2)
		{
			Ng2++;
		}
		if(nGam>2)
		{
			NgAbove2++;
		}
	}
	if(nGam!=0)
	{
		return StatusCode::SUCCESS;
	} 
	Ncut2++;
/*
	if(m_writePredata==1)
	{
		double e_epremass=0.0;
		double e_mupremass=0.0;
		double p_pre=0.0;

		for(int i = 0; i < nGood; i++){
			EvtRecTrackIterator itTrk=evtRecTrkCol->begin() + iGood[i];
			if(!(*itTrk)->isMdcTrackValid()) continue;

			RecMdcTrack *mdcTrk = (*itTrk)->mdcTrack();
			p_pre=mdcTrk->p();

			e_epremass+=sqrt(p_pre*p_pre+xmass[0]*xmass[0]);
			e_mupremass+=sqrt(p_pre*p_pre+xmass[1]*xmass[1]);

			if(i==0)
			{
				m_prep1=p_pre;
			}
			else if(i==1)
			{
				m_prep2=p_pre;
				m_epremass=e_epremass;
				m_mupremass=e_mupremass;
			}
		}
		m_tuple14->write();
	}
*/




	if(m_checkMuc==1)
	{

		double p_pos=0.0;
		double p_neg=0.0;
		for(int i=0;i<nGood;i++)
		{
			EvtRecTrackIterator itTrk = evtRecTrkCol->begin()+iGood[i];

			if(!(*itTrk)->isMucTrackValid()) continue;
			if(!(*itTrk)->isMdcTrackValid()) continue;

			RecMdcTrack *mdcTrk = (*itTrk)->mdcTrack();
			RecMucTrack *mucTrk = (*itTrk)->mucTrack();

			if(mdcTrk->charge()>0)
			{
				m_posdepthMuc=mucTrk->depth();
				m_poslayerMuc=mucTrk->numLayers();
				p_pos=mdcTrk->p();
			}

			if(mdcTrk->charge()<0)
			{
				m_negdepthMuc=mucTrk->depth();
				m_neglayerMuc=mucTrk->numLayers();
				p_neg=mdcTrk->p();
			}

			else
			{
				return StatusCode::SUCCESS;
			}
		}
		if(m_poslayerMuc<2 || m_neglayerMuc<2) return StatusCode::SUCCESS;

		if(p_pos>0.4 && p_pos<1.1)
		{
			if(m_posdepthMuc < -40+70*p_pos) return StatusCode::SUCCESS;
		}
		if(p_pos>1.1)
		{
			if(m_posdepthMuc < 41) return StatusCode::SUCCESS;
		}

		if(p_neg>0.4 && p_neg<1.1)
		{
			if(m_negdepthMuc < -40+70*p_neg) return StatusCode::SUCCESS;
		}
		if(p_neg>1.1)
		{
			if(m_negdepthMuc < 41) return StatusCode::SUCCESS;
		}
		Ncut4++;

	}

//	m_tuple12->write();	
//	m_tuple15->write();	
//	Ncut9++;
	/*
	   if(m_checkRatio==1)
	   {
	   double ene_cur[2];
	   int count_dou=0; 

	   for(int i=0;i<nGood;i++)
	   {
	   EvtRecTrackIterator itTrk = evtRecTrkCol->begin()+iGood[i];

	   if(!(*itTrk)->isMdcTrackValid()) continue;
	   if(!(*itTrk)->isExtTrackValid()) continue;

	   RecMdcTrack *mdcTrk = (*itTrk)->mdcTrack();
	   RecExtTrack *extTrk=(*itTrk)->extTrack();

	   if(extTrk->emcVolumeNumber()==-1) continue;
	   Hep3Vector extpos = extTrk->emcPosition();

	   double dthe = 200.;
	   double dphi = 200.;
	   double dang = 200.; 
	   double eraw = 0.0;

	   for(int j=0;j<nGam;j++)
	   {
	   EvtRecTrackIterator jtTrk=evtRecTrkCol->begin()+iGam[j];
	//for(int j=evtRecEvent->totalCharged();j<evtRecEvent->totalTracks();j++){
	//EvtRecTrackIterator jtTrk=evtRecTrkCol->begin()+j;

	if(!(*jtTrk)->isEmcShowerValid()) continue;
	RecEmcShower *emcTrk=(*jtTrk)->emcShower();
	Hep3Vector emcpos(emcTrk->x(),emcTrk->y(),emcTrk->z());

	double angd = extpos.angle(emcpos);
	double thed = extpos.theta() - emcpos.theta();
	double phid = extpos.deltaPhi(emcpos);

	thed = fmod(thed+CLHEP::twopi+CLHEP::twopi+pi, CLHEP::twopi) - CLHEP::pi;
	phid = fmod(phid+CLHEP::twopi+CLHEP::twopi+pi, CLHEP::twopi) - CLHEP::pi;
	if(angd < dang)
	{
	dang = angd;
	dthe = thed;
	dphi = phid;
	eraw = emcTrk->energy();
	}
	}  
	if(dang>=200) return StatusCode::SUCCESS;
	dthe = dthe *180/(CLHEP::pi);
	dphi = dphi *180/(CLHEP::pi);
	dang = dang *180/(CLHEP::pi);

	if( eraw < m_ene_lowThreshold || eraw > m_ene_highThreshold) return StatusCode::SUCCESS;
	double pt_cur=mdcTrk->pxy();
	double p_cur=mdcTrk->p();
	double ep_ratio_cur=eraw/p_cur;
	//		   double ep_ratio_cur=0.2;
	if(pt_cur < m_pt_Threshold)  return StatusCode::SUCCESS;
	if(ep_ratio_cur > m_ep_ratioThreshold) return StatusCode::SUCCESS;

	m_e_ratio=eraw;
	m_p_ratio=p_cur;
	m_ep_ratio=ep_ratio_cur;

	m_tuple12->write();
	ene_cur[i]=eraw;
	count_dou++;
	Ncut7++;
	}
	if(count_dou==2)
	{
		m_ene1=ene_cur[0];
		m_ene2=ene_cur[1];
		m_tuple13->write();
		Ncut8++;
	}
}
*/
///////////////////////////////////Vertex fit///////////////////////////////

RecMdcKalTrack *mupTrk = (*(evtRecTrkCol->begin()+iGood[0]))->mdcKalTrack();
RecMdcKalTrack *mumTrk = (*(evtRecTrkCol->begin()+iGood[1]))->mdcKalTrack();

WTrackParameter wvmupTrk, wvmumTrk;
wvmupTrk = WTrackParameter(mmu, mupTrk->getZHelixMu(), mupTrk->getZErrorMu());
wvmumTrk = WTrackParameter(mmu, mumTrk->getZHelixMu(), mumTrk->getZErrorMu());

HepPoint3D vx(0., 0., 0.);
HepSymMatrix Evx(3, 0);
double bx = 1E+6;
double by = 1E+6;
double bz = 1E+6;
Evx[0][0] = bx*bx;
Evx[1][1] = by*by;
Evx[2][2] = bz*bz;

VertexParameter vxpar;
vxpar.setVx(vx);
vxpar.setEvx(Evx);

VertexFit* vtxfit = VertexFit::instance();
vtxfit->init();
vtxfit->AddTrack(0,  wvmupTrk);
vtxfit->AddTrack(1,  wvmumTrk);
vtxfit->AddVertex(0, vxpar,0, 1);
if(!vtxfit->Fit(0)) return SUCCESS;
vtxfit->Swim(0);

WTrackParameter wmup = vtxfit->wtrk(0);
WTrackParameter wmum = vtxfit->wtrk(1);

///////////////////////////////////apply 4C fit/////////////////////////////

KalmanKinematicFit * kmfit = KalmanKinematicFit::instance();

if(m_test4C==1)
{
	HepLorentzVector ecms(0.034,0,0,3.097);
	double chisq = 9999.;
	kmfit->init();
	kmfit->AddTrack(0,wmup);
	kmfit->AddTrack(1,wmum);
	kmfit->AddFourMomentum(0,ecms);
	bool oksq = kmfit->Fit();
	if(oksq) 
	{
		HepLorentzVector mumu0 = kmfit->pfit(0) + kmfit->pfit(1);
		m_mmu0 = mumu0.m();
		m_chi1 = kmfit->chisq();
//		m_tuple4->write();
		Ncut5++;
	}
	else
	{
		return StatusCode::SUCCESS;

	}
}
////////////////////////////////////end of 4C////////////////////////////////
	if(m_checkRatio==1)
	{
		for(int i=0;i<nGood;i++)
		{
			EvtRecTrackIterator itTrk = evtRecTrkCol->begin()+iGood[i];

			if(!(*itTrk)->isMdcTrackValid()) continue;
			if(!(*itTrk)->isEmcShowerValid()) continue;

			RecMdcTrack *mdcTrk = (*itTrk)->mdcTrack();
			RecEmcShower *emcTrk=(*itTrk)->emcShower();

			if(mdcTrk->charge()>0)
			{
				m_ppos_ratio=mdcTrk->p();
				m_epos_ratio=sqrt(m_ppos_ratio*m_ppos_ratio+xmass[1]*xmass[1]);
				m_depos_ratio=emcTrk->energy();
				m_eppos_ratio=m_depos_ratio/m_ppos_ratio;
			}

			else if(mdcTrk->charge()<0)
			{
				m_pneg_ratio=mdcTrk->p();
				m_eneg_ratio=sqrt(m_pneg_ratio*m_pneg_ratio+xmass[1]*xmass[1]);
				m_deneg_ratio=emcTrk->energy();
				m_epneg_ratio=m_deneg_ratio/m_pneg_ratio;
			}
			else
			{
				return StatusCode::SUCCESS;
			}

		}

		m_tmass_ratio=m_epos_ratio+m_eneg_ratio;

		//here is cut
		/*	
		if(m_depos_ratio<m_ene_lowThreshold || m_depos_ratio>m_ene_highThreshold) return StatusCode::SUCCESS;
		if(m_deneg_ratio<m_ene_lowThreshold || m_deneg_ratio>m_ene_highThreshold) return StatusCode::SUCCESS;

		if(m_eppos_ratio > m_ep_ratioThreshold) return StatusCode::SUCCESS;
		if(m_epneg_ratio > m_ep_ratioThreshold) return StatusCode::SUCCESS;
		*/
	}
	Ncut3++;

/////////////////////////////////apply 5C fit////////////////////////////////

if(m_test5C==1)
{
	HepLorentzVector ecms(0.034,0,0,3.097);
	kmfit->init();
	kmfit->AddTrack(0, wmup);
	kmfit->AddTrack(1, wmum);
	kmfit->AddResonance(0, 3.097, 0, 1);
	kmfit->AddFourMomentum(1, ecms);
	bool oksq = kmfit->Fit();
	//  log << MSG::INFO << " chisq = " << chisq <<endreq;
	if(oksq)
	{
		HepLorentzVector mumu1 = kmfit->pfit(0) + kmfit->pfit(1);
		m_chi2  = kmfit->chisq();
		m_mmu1 =mumu1.m();
		//	double eg1 = (kmfit->pfit(2)).e();
		//	double eg2 = (kmfit->pfit(3)).e();
		//	double fcos = abs(eg1-eg2)/ppi0.rho();
		//m_tuple5->write();
		Ncut6++;
	}
	else
	{
		return StatusCode::SUCCESS;
	}
	// 
	//  Measure the photon detection efficiences via
	//          J/psi -> rho0 pi0
	//
	/*
	   if(fabs(prho0.m()-0.770)<0.150) {  
	   if(fabs(fcos)<0.99) {
	   m_fcos = (eg1-eg2)/ppi0.rho();
	   m_elow =  (eg1 < eg2) ? eg1 : eg2;
	   m_tuple6->write();
	   Ncut6++;
	   }
	   } // rho0 cut
	   }  //oksq
	   */
}

int wResult=0;
if(wResult==1)
{
	for(int i=0;i<nGood;i++)
	{

		EvtRecTrackIterator itTrk = evtRecTrkCol->begin()+iGood[i];

		if(!(*itTrk)->isMdcTrackValid()) continue;
		RecMdcTrack *mdcTrk = (*itTrk)->mdcTrack();

		if(mdcTrk->charge()>0)
		{
			m_pposmu=mdcTrk->p();
			m_eposmu=sqrt(m_pposmu*m_pposmu+xmass[1]*xmass[1]);
		}

		else if(mdcTrk->charge()<0)
		{
			m_pnegmu=mdcTrk->p();
			m_enegmu=sqrt(m_pnegmu*m_pnegmu+xmass[1]*xmass[1]);
		}
		else
		{
			return StatusCode::SUCCESS;
		}
	}
	m_tmassmumu=m_eposmu+m_enegmu;
//	m_tuple16->write();
}
TreeAna->Fill();
return StatusCode::SUCCESS;
}

//***************************************************************************



// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
StatusCode Rhopi::finalize() {
	saveFile->cd();
	TreeAna->Write();
	saveFile->Close();


	cout<<"lify's finalize has completed!"<<endl;
	cout<<"Total number:         "<<Ncut0<<endl;
	cout<<"nGood==2, nCharge==0: "<<Ncut1<<endl;
	cout<<"nGam=0:               "<<Ncut2<<endl;
	//  cout<<"Pass Pid:             "<<Ncut3<<endl;
	//  cout<<"Pass 4C:              "<<Ncut4<<endl;
	//  cout<<"Pass 5C:              "<<Ncut5<<endl;
	//  cout<<"J/psi->rho0 pi0:      "<<Ncut6<<endl;
	/* 
	cout<<"nGam=1:               "<<Ng1<<endl;
	cout<<"nGam=2:               "<<Ng2<<endl;
	cout<<"nGam>2:               "<<NgAbove2<<endl;
	*/
	//  cout<<"Only 1  partile Pass: "<<Ncut7<<endl;
	if(m_checkRatio==1) cout<<"The event Pass E/p:   "<<Ncut3<<endl;
	if(m_checkMuc==1) cout<<"The event Pass MUC:   "<<Ncut4<<endl;
	if(m_test4C==1) cout<<"The event Pass 4C:   "<<Ncut5<<endl;
	if(m_test5C==1) cout<<"The event Pass 5C:   "<<Ncut6<<endl;


	MsgStream log(msgSvc(), name());
	log << MSG::INFO << "in finalize()" << endmsg;
	return StatusCode::SUCCESS;
}

